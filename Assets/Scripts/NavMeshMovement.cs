using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class NavMeshMovement : MonoBehaviour
{
    // Global variables used throughout the script. May be changed from the Unity Editor.
    public float wanderWaitTime = 2.0f; // in seconds
    public float wanderTriggerChance = 0.3f; // has to be between 0 and 1
    public float avoidDistance = 4.0f;
    public float cooldownTime = 30f;

    private float baseSpeed; // used to remember the speed of the NavMesh agent

    [SerializeField]
    private Transform player;

    [SerializeField]
    private Transform bait;

    public float agentSpeed = 6.0f;
    public float agentAcceleration = 8.0f;

    public float baitDetectionDistance = 6.0f;

    private Animator animator;
    private NavMeshAgent agent;
    private Coroutine currentCoroutine;

    private bool isMovingToBait = false; // checks if moving towards bait

    // Variables used for the GameObject's avoiding behavior.
    private bool isAvoiding = false;
    private bool recentlyAvoided = false;
    private int increment = 1;


    // Start is called before the first frame update

    void Start()
    {
        Debug.Log("Starting Object!");
        animator = GetComponent<Animator>();
        agent = GetComponent<NavMeshAgent>();

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        if (agent == null)
        {
            Debug.LogError("NavMeshAgent component not found!");
            return;
        }

        // Set agent speed and acceleration
        baseSpeed = agentSpeed;
        agent.speed = agentSpeed;
        agent.acceleration = agentAcceleration;

        currentCoroutine = StartCoroutine(Wander());
    }

    /// <summary>
    /// Wandering movement of the asset. Follows a randomly generated
    /// path.
    /// </summary>
    IEnumerator Wander()
    {
        while (true)
        {
            yield return new WaitForSeconds(wanderWaitTime);
            if (Random.value < wanderTriggerChance)
            {
                if (animator != null)
                {
                    animator.SetBool("Moving", true);
                }

                Vector3 wanderTarget = GetRandomNavMeshLocation();
                Debug.Log("Wandering to: " + wanderTarget);
                agent.SetDestination(wanderTarget);

                while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
                {
                    yield return null;
                }

                if (animator != null)
                {
                    animator.SetBool("Moving", false);
                }
            }
        }
    }

    /// <summary>
    /// Generates a random position on the NavMesh. The NavMesh agent,
    /// the GameObject, will move in the direction generated by this method.
    /// </summary>
    /// <returns> A vector pointing towards the random direction </returns>
    Vector3 GetRandomNavMeshLocation()
    {
        Vector3 randomDirection = Random.insideUnitSphere * avoidDistance;
        randomDirection += transform.position;
        NavMeshHit navHit;
        NavMesh.SamplePosition(randomDirection, out navHit, avoidDistance, NavMesh.AllAreas);
        return navHit.position;
    }

    /// <summary>
    /// Avoiding behavior of the GameObject. It moves away from the player.
    /// TODO: Implement faster animation for fast speeds.
    /// </summary>
    IEnumerator Avoid()
    {
        isAvoiding = true;
        Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;

        if (recentlyAvoided && increment < 2)
        {
            increment += 1;
        }

        float modifier = Mathf.Pow(1.5f, increment);
        agent.speed = baseSpeed * modifier;

        Vector3 avoidTarget = transform.position + directionAwayFromPlayer * (modifier * avoidDistance);

        NavMeshHit navHit;
        NavMesh.SamplePosition(avoidTarget, out navHit, avoidDistance, NavMesh.AllAreas);

        if (animator != null)
        {
            animator.SetBool("Moving", true);
        }

        Debug.Log("Avoiding to: " + navHit.position);
        agent.SetDestination(navHit.position);

        while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
        {
            yield return null;
        }

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        if (!recentlyAvoided)
        {
            recentlyAvoided = true;
        }

        isAvoiding = false;

        currentCoroutine = StartCoroutine(Wander());

        StartCoroutine(AvoidCooldown());
    }

    /// <summary>
    /// Helper method that makes the GameObject moves towards
    /// the designated bait object.
    /// </summary>
    /// <returns></returns>
    IEnumerator MoveToBait()
    {
        isMovingToBait = true;
        if (animator != null)
        {
            animator.SetBool("Moving", true);
        }

        Debug.Log("Moving to bait: " + bait.position);
        agent.SetDestination(bait.position);

        while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
        {
            yield return null;
        }

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        isMovingToBait = false;
        currentCoroutine = StartCoroutine(Wander());
    }

    /// <summary>
    /// Helper method that checks if the player has been within avoid distance of the GameObject
    /// for a set amount of time, resetting the avoid speed of the GameObject if the player has not.
    /// </summary>
    IEnumerator AvoidCooldown()
    {
        float elapsedT = 0f;
        while (elapsedT < cooldownTime)
        {
            if (Vector3.Distance(player.position, transform.position) <= avoidDistance)
            {
                yield break;
            }
            elapsedT += Time.deltaTime;
            yield return null;
        }
        increment = 0;
        recentlyAvoided = false;
        agent.speed = baseSpeed;
    }

    /// <summary>
    /// Update is called once per frame. It is used to check the distance between the player, 
    /// bait, and the GameObject.
    /// </summary>
    void Update()
    {
        float distanceFromPlayer = Vector3.Distance(transform.position, player.position);
        float distanceFromBait = Vector3.Distance(transform.position, bait.position);

        if (distanceFromBait <= baitDetectionDistance && distanceFromPlayer >= avoidDistance && !isMovingToBait)
        {
            if (currentCoroutine != null)
            {
                StopCoroutine(currentCoroutine);
            }
            currentCoroutine = StartCoroutine(MoveToBait());
        }
        else if (distanceFromPlayer < avoidDistance && !isAvoiding && !isMovingToBait)
        {
            if (currentCoroutine != null)
            {
                StopCoroutine(currentCoroutine);
            }
            currentCoroutine = StartCoroutine(Avoid());
        }
    }
}
